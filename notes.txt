
>>> TUTORIAL 1 <<<
https://www.youtube.com/watch?v=UmljXZIypDc

- make virtualenv for django project
- install django
	$ pip install django  # install django
	$ python -m django --version  # check version
		django v3.0.5
		python 3.7.4

- view django subcommands
	$ django-admin
- start django project (django-admin, subcommand, name)
	$ django-admin startproject ira_django_project
	- folder ira_django_project should be in dir
	- open folder in text editor or view tree of current dir

$ tree .
.
├── ira_django_project
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py
	
- manage.py allows us to run command line commands
- settings.py under ira_django_project -- use to change configuration of app
	- will be changing as we go along
	- SECRET_KEY -- adds security enhancement to django
- urls.py
	- use this for redirect of urls
	- look at urlpatterns (<type list>)
- wsgi.py (pronounced like whiskey)
	- how our webapp and webserver communicate

- to open the application:
	- $ python manage.py runserver
	- migration warnings will be thrown
	- http://127.0.0.1 == localhost
	- e.g. localhost:8000 will also work (local host with port 8000)
	- to nav to admin:
		- http://localhost:8000/admin
		- enabled by urlpatterns in url.py
	- CTRL+C to stop server in terminal
	- with DEBUG=True, out website should reflect any changes in real time.





>>> TUTORIAL 2 <<<
https://www.youtube.com/watch?v=a48xeeo5Vnk

- a single project can creat multiple apps
	- e.g. the blog application is an object (almost)
	- drag and drop of apps to different projects is doable

- create a new django app (python, manage.py, startapp, app_name)
	- $ python manage.py startapp blog
- let's take a look at the tree structure of our dir:

$ tree .
.
├── blog
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py

- notice the blog directory with its own structure
	- a lot of files created simply by creating the blog app -- could be intimidating to some. 
- NOTE: if no db.sqlite3 present in project directory, create db.sqlite3 by running:
	- $ python manage.py migrate

- in blog/views.py, add line:
	from django.http import HttpResponse
	- build a homepage navigator here
- then, make blog/urls.py to map urls to correspond to each views.py method
	- write something similar to the urls.py file in the project dir
	- import views in urls.py
		from . import views
	- set path to home with name 'blog-home'
		- be detailed with the name
	- import include from django.urls (urls.py in ira_django_project dir) to specify url routing

- NOTE: disabling pycache dir formation will allow you to view your server as it changes without searching cache
	- to do this, go to your virtualenv and write:
	$ export PYTHONDONTWRITEBYTECODE=1

- if you type localhost:8000/blog:
	- look at ira_django_project/urls.py
	- look for 'blog/' in urlpatterns
	- look at include('blog.urls')
		- send an empty string (chop off 'blog/' to '') to blog.urls
		- look at the urlpatterns in blog dir (notice the empty route)
- if we want to look up localhost:8000/blog/about
	- ira_django_project/urls.py will look for blog/
	- then it will send an empty string to blog.urls ''
	- finally, it will look for 'about/' in urlpatterns
		- call module in second arg in path('about/', args, kwargs)
- if we change the blog reroute to blog_dev (ira_django_project/urls.py), we'd have to change /blog to /blog_dev
	- same for blog/about to blog_dev/about

- we add trailing slashes to urlpatters because by default it will stick it on(?)
	- makes it easier to debug

- if we want to go to the homepage via localport:8000, we will have to change:
	- (in urls.py -- ira_django_project) add an empty path
	- change path('blog/', include('blog.urls')) to path('', include('blog.urls'))

$ tree .
.
├── blog
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py





>>> TUTORIAL 3 <<<
https://www.youtube.com/watch?v=qDwdMDQ8oX4

- we want to use templates in our html to save us from having to write large html5 files
- to do this we want to make a templates dir in our blog app dir
	- in our blog dir, $ mkdir templates
- by default django looks for templates in each of our installed apps
- create another dir in our templates dir with the same name as our app (blog) (django convention)
	- in our templates dir, $ mkdir blog

- within this blog dir, (in our case) add our htmls
	- home.html
	- about.html
- fill these html appropriately

- configure these htmls in the ira_django_project/blog/apps.py file
	- add name of class BlogConfig to our ira_django_projects/settings.py file
	- in INSTALLED_APPS, add 'blog.apps.BlogConfig' at index 0
	- this is a common process, get used to adding applications to this list

- modify reroute in blog/views.py file
	- e.g. in our home func (home(func)), write this:
		return render(request, 'blog/home.html')
		- this will look in the templates dir as the base dir
		- i.e. it will fing blog/home.html in templates/
	- the render func returns an http response in the background
	- runserver and you can inspect view pagesource for new content (i.e. new redirect)

- if we make a redirect to about.html in blog/templates/blog/, we do not need to add this configuration to our apps.py
	- note, 'blog' is already added as a var in class BlogConfig(AppConfig)

- now let's try to add content to our page in views.py
	- make a list, dict (JSON like obj) in var posts
	e.g. 
	posts = [
    		{
        "author": 'IraH',
        "title": 'Blog Post 1',
        "content": 'First post content',
        "date_posted": 'April 15, 2020'  # usually a datetime obj
    		}
	]
	- now in our home func, add local var context, a dict, with 'posts': posts
	- pass context as third arg to render

- django has a templating engine that allows us to write code within our html file
	- very similar to jinja2
	- every iterator or conditional must have an end
	{% for i in x %}
	{% end for %}
	- use double curly braces to call var
	{{ i }}

- loop over context looking for keys and values - add this to your html to generate static language dynamically
- conditionals using django template:
	{% if x %}
		do something
	{% else %}
		do something
	{% endif %}

- use template inheritance to concise code and keep unique to each route
- i.e. make a page that has html properties shared among your html files
- child pages (i.e. html files that inherit base) will override the base template
	- delete base template properties in your children pages
- making a base template
	- make base.html under blog/templates/blog
	- write your base html page (doctype, html, headers, etc)
	- use {% block content %}{% endblock %} where content children pages will vary
	- inherit base.html in children pages by:
		{% extends "blog/base.html" %}
	- now inherit this base template in your children pages as follows:
		{% block content %}
		    {% for post in posts %}
        		<h1>{{ post.title }}</h1>
       			<p>By {{ post.author }} on {{ post.date_posted }}</p>
        		<p>{{ post.content }}</p>
    		{% endfor %}
		{% endblock content %}

- use bootstrap to add HTML JS and CSS styling to your page easily
	- copy code from site: https://getbootstrap.com/docs/4.3/getting-started/introduction/#starter-template
- this is where template inheritance shines - only change to base, not to all pages
	- copy code in the right place (head to head, body to body) in base.html
	- make <div class="container"></div> to give good padding.
- look at correy's html code snippets here https://github.com/CoreyMSchafer/code_snippets
- CSS and JS need to be stored in a static directory in our app
	- make a directory "static" under ira_django_project/blog directory
	- navigate to static and mkdir "blog" (same name as our app)
	- create main.css file - copy corey's snippet put in here
	- at top of our base.html, input {% load static %} to load css file from static dir
	- add main.css in line 13 of base.html
		- static generates an absolute url of the static files - access blog/main.css

- use the django url tag to get absolute path to a url pattern
	- e.g. {% url 'blog-home' %} means open up the url for name='blog-home' in urlpatterns

$ tree .
.
├── blog
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── apps.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       └── home.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py





>>> TUTORIAL 4 <<<
https://www.youtube.com/watch?v=1PkNiYlkkjo

- we must create an admin user to access admin capabilities
- $ python manage.py createsuperuser
	- before we do this, we must create a database
	- $ python manage.py makemigrations
		- prepares django to update the database
		- doesn't run changes yet
	- $ python manage.py migrate
		- should be ok and auth_table should exist

- try createsuperuser again, add username, email, and password
- now try signing in to /admin - it should work
- django stores the hashing of our passwords automatically
- click add user in the user path (admin) to make new user
	- add members that are allowed to manipulate the admin page
	- different levels of permissions are allowed
	- deleting users is also possible here

- we can also see recent actions in /admin page - kind of like version control
	- pencil is edit
	- + is add

tree .                                                                                            ─╯
.
├── blog
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── apps.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       └── home.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py




























