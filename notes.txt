
>>> TUTORIAL 1 <<<
https://www.youtube.com/watch?v=UmljXZIypDc

- make virtualenv for django project
- install django
	$ pip install django  # install django
	$ python -m django --version  # check version
		django v3.0.5
		python 3.7.4

- view django subcommands
	$ django-admin
- start django project (django-admin, subcommand, name)
	$ django-admin startproject ira_django_project
	- folder ira_django_project should be in dir
	- open folder in text editor or view tree of current dir

$ tree .
.
├── ira_django_project
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py
	
- manage.py allows us to run command line commands
- settings.py under ira_django_project -- use to change configuration of app
	- will be changing as we go along
	- SECRET_KEY -- adds security enhancement to django
- urls.py
	- use this for redirect of urls
	- look at urlpatterns (<type list>)
- wsgi.py (pronounced like whiskey)
	- how our webapp and webserver communicate

- to open the application:
	- $ python manage.py runserver
	- migration warnings will be thrown
	- http://127.0.0.1 == localhost
	- e.g. localhost:8000 will also work (local host with port 8000)
	- to nav to admin:
		- http://localhost:8000/admin
		- enabled by urlpatterns in url.py
	- CTRL+C to stop server in terminal
	- with DEBUG=True, out website should reflect any changes in real time.





>>> TUTORIAL 2 <<<
https://www.youtube.com/watch?v=a48xeeo5Vnk

- a single project can creat multiple apps
	- e.g. the blog application is an object (almost)
	- drag and drop of apps to different projects is doable

- create a new django app (python, manage.py, startapp, app_name)
	- $ python manage.py startapp blog
- let's take a look at the tree structure of our dir:

$ tree .
.
├── blog
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py

- notice the blog directory with its own structure
	- a lot of files created simply by creating the blog app -- could be intimidating to some. 
- NOTE: if no db.sqlite3 present in project directory, create db.sqlite3 by running:
	- $ python manage.py migrate

- in blog/views.py, add line:
	from django.http import HttpResponse
	- build a homepage navigator here
- then, make blog/urls.py to map urls to correspond to each views.py method
	- write something similar to the urls.py file in the project dir
	- import views in urls.py
		from . import views
	- set path to home with name 'blog-home'
		- be detailed with the name
	- import include from django.urls (urls.py in ira_django_project dir) to specify url routing

- NOTE: disabling pycache dir formation will allow you to view your server as it changes without searching cache
	- to do this, go to your virtualenv and write:
	$ export PYTHONDONTWRITEBYTECODE=1

- if you type localhost:8000/blog:
	- look at ira_django_project/urls.py
	- look for 'blog/' in urlpatterns
	- look at include('blog.urls')
		- send an empty string (chop off 'blog/' to '') to blog.urls
		- look at the urlpatterns in blog dir (notice the empty route)
- if we want to look up localhost:8000/blog/about
	- ira_django_project/urls.py will look for blog/
	- then it will send an empty string to blog.urls ''
	- finally, it will look for 'about/' in urlpatterns
		- call module in second arg in path('about/', args, kwargs)
- if we change the blog reroute to blog_dev (ira_django_project/urls.py), we'd have to change /blog to /blog_dev
	- same for blog/about to blog_dev/about

- we add trailing slashes to urlpatters because by default it will stick it on(?)
	- makes it easier to debug

- if we want to go to the homepage via localport:8000, we will have to change:
	- (in urls.py -- ira_django_project) add an empty path
	- change path('blog/', include('blog.urls')) to path('', include('blog.urls'))

$ tree .
.
├── blog
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py





>>> TUTORIAL 3 <<<
https://www.youtube.com/watch?v=qDwdMDQ8oX4

- we want to use templates in our html to save us from having to write large html5 files
- to do this we want to make a templates dir in our blog app dir
	- in our blog dir, $ mkdir templates
- by default django looks for templates in each of our installed apps
- create another dir in our templates dir with the same name as our app (blog) (django convention)
	- in our templates dir, $ mkdir blog

- within this blog dir, (in our case) add our htmls
	- home.html
	- about.html
- fill these html appropriately

- configure these htmls in the ira_django_project/blog/apps.py file
	- add name of class BlogConfig to our ira_django_projects/settings.py file
	- in INSTALLED_APPS, add 'blog.apps.BlogConfig' at index 0
	- this is a common process, get used to adding applications to this list

- modify reroute in blog/views.py file
	- e.g. in our home func (home(func)), write this:
		return render(request, 'blog/home.html')
		- this will look in the templates dir as the base dir
		- i.e. it will fing blog/home.html in templates/
	- the render func returns an http response in the background
	- runserver and you can inspect view pagesource for new content (i.e. new redirect)

- if we make a redirect to about.html in blog/templates/blog/, we do not need to add this configuration to our apps.py
	- note, 'blog' is already added as a var in class BlogConfig(AppConfig)

- now let's try to add content to our page in views.py
	- make a list, dict (JSON like obj) in var posts
	e.g. 
	posts = [
    		{
        "author": 'IraH',
        "title": 'Blog Post 1',
        "content": 'First post content',
        "date_posted": 'April 15, 2020'  # usually a datetime obj
    		}
	]
	- now in our home func, add local var context, a dict, with 'posts': posts
	- pass context as third arg to render

- django has a templating engine that allows us to write code within our html file
	- very similar to jinja2
	- every iterator or conditional must have an end
	{% for i in x %}
	{% end for %}
	- use double curly braces to call var
	{{ i }}

- loop over context looking for keys and values - add this to your html to generate static language dynamically
- conditionals using django template:
	{% if x %}
		do something
	{% else %}
		do something
	{% endif %}

- use template inheritance to concise code and keep unique to each route
- i.e. make a page that has html properties shared among your html files
- child pages (i.e. html files that inherit base) will override the base template
	- delete base template properties in your children pages
- making a base template
	- make base.html under blog/templates/blog
	- write your base html page (doctype, html, headers, etc)
	- use {% block content %}{% endblock %} where content children pages will vary
	- inherit base.html in children pages by:
		{% extends "blog/base.html" %}
	- now inherit this base template in your children pages as follows:
		{% block content %}
		    {% for post in posts %}
        		<h1>{{ post.title }}</h1>
       			<p>By {{ post.author }} on {{ post.date_posted }}</p>
        		<p>{{ post.content }}</p>
    		{% endfor %}
		{% endblock content %}

- use bootstrap to add HTML JS and CSS styling to your page easily
	- copy code from site: https://getbootstrap.com/docs/4.3/getting-started/introduction/#starter-template
- this is where template inheritance shines - only change to base, not to all pages
	- copy code in the right place (head to head, body to body) in base.html
	- make <div class="container"></div> to give good padding.
- look at correy's html code snippets here https://github.com/CoreyMSchafer/code_snippets
- CSS and JS need to be stored in a static directory in our app
	- make a directory "static" under ira_django_project/blog directory
	- navigate to static and mkdir "blog" (same name as our app)
	- create main.css file - copy corey's snippet put in here
	- at top of our base.html, input {% load static %} to load css file from static dir
	- add main.css in line 13 of base.html
		- static generates an absolute url of the static files - access blog/main.css

- use the django url tag to get absolute path to a url pattern
	- e.g. {% url 'blog-home' %} means open up the url for name='blog-home' in urlpatterns

$ tree .
.
├── blog
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── apps.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       └── home.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py





>>> TUTORIAL 4 <<<
https://www.youtube.com/watch?v=1PkNiYlkkjo

- we must create an admin user to access admin capabilities
- $ python manage.py createsuperuser
	- before we do this, we must create a database
	- $ python manage.py makemigrations
		- prepares django to update the database
		- doesn't run changes yet
	- $ python manage.py migrate
		- should be ok and auth_table should exist

- try createsuperuser again, add username, email, and password
- now try signing in to /admin - it should work
- django stores the hashing of our passwords automatically
- click add user in the user path (admin) to make new user
	- add members that are allowed to manipulate the admin page
	- different levels of permissions are allowed
	- deleting users is also possible here

- we can also see recent actions in /admin page - kind of like version control
	- pencil is edit
	- + is add

tree .                                                                                            
.
├── blog
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── apps.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       └── home.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py





>>> TUTORIAL 5 <<< 
https://www.youtube.com/watch?v=aHC3uTkT9r8

- django has its own built in ORM
	- ORM = object relational mapper
		- allows us to access our DB in an OOP way
		- use different databases without changing code
			- sqlite
			- postgresql
		- still same code to talk with database

- we will use sqlite for developing, postgresql for production
- we can rep database structure as classes in django
	- these classes are called models
- go to models.py in the blog dir
- we have to think about what we want to save to db, e.g.
	- user (django has this built in)
	- posts

- let's create a Post class to add posts to db
	- create Post class that inherits from models.Model
	- now create what we will store, e.g.:
		- title = models.CharField(max_length=100)  # max char len
		- use models.TextField() for large text body
		- use models.DateTimeField(default=timezone.now) 
			- for above, import timezone from django.utils
		- auto_now=True  # is update dateposted to current time when updated
		- auto_now_add = True  # only when the obj was created
	- now we want to import user attributes
		- from django.contrib.auth.models import User
			- pass this into: models.ForeignKey(User, on_delete=models.CASCADE). # delete posts if user deleted
			- on_delete means what to do if user is deleted

- we must rerun migrations to reflect these changes in the db
	- python manage.py migrations
	- you'll notice that 0001_init.py was made in the blog/migrations dir
		- this fill will be run when you migrate the db

- we can view the SQL code that will be run when we migrate the db
	- in our case, we run:
		- python manage.py sqlmigrate 0001
		- we will see the SQL code it will run
	- the models.py code ran the SQL code for us
		- we don't need to know SQL
	- one of the great traits of ORM
	- now we can reflect these changes to the database:
	- python manage.py migrate

- migrations are useful because we can change db even after it is created and there is content
	- using migrate allows us to make these changes

- we can run the django-python shell by running:
	- python manage.py shell
	- this is a great way to look at the db in a python env
	- e.g.:
		from blog.models import Post
		from django.contrib.auth.models import User
		User.objects.all()  # get all users
		User.objects.first()  # get first user
		User.objects.filter(username='irahorecka')  # get user by name
		# sometimes, the above code can give back multiple users.
		User.objects.filter(username='irahorecka').first()  # get first user by key
		user = User.objects.filter(username='irahorecka').first()  # assign to var
		user.id  # get id
		user.pk  # get user primary key
		user = User.objects.get(id=1)  # get user by id

- let's make a new post with the author as user
	- check posts in teh Post table:
		Post.objects.all()
	- make post
		post_1 = Post(title='Blog 1', content='First Post Content!', author=user)
			- for our Post, datetime should be automatically filled
		- we have to save post_1 to the db for it to reflect the change
			post_1.save()
	- check content of db in detail
		- make a __str__ method in Post, return title
		Post.objects.all() 
	- to make another post using user id for author id:
		post_2 = Post(title='Blog 2', content='Second Post Content!', author_id=user.id)
	- assign first post to var and return attributes
		post = Post.objects.first()
		post.content  # (find content of post) -- content is a field we assigned
		post.date_posted  # datetime this blog post was posted
		post.author  # returns user obj -- even access user's attribute
		poast.author.email  # get the author's email address
	- get all posts created by the user (user is a var we assigned)
		user.post_set. # returns obj
		# run queries against user.post_set
		user.post_set.all()  # get all posts authored by this user
	- create a post by the user using user var
		user.post_set.create(title='Blog 3', content='Third post content!')
		- this way, we don't have to assign user (already instantiated) nor do we have to call post_x.save()

- how to integrate db data to our website
	- open blog/views.py
	- from .models import Post (db instance)
	- set key of context to Post.object.all()

- change datetime format
	- post.date_posted|date:"F d, Y"  # for date formatting to April 22, 2019, e.g.
- to see our post (Post) db in our admin page, we must register the obj with admin
	- go to blog/admin.py to register your model
	- from .models import Post  # import our model
	- admin.site.register(Post)  # register our db obj
	- you should see it on your admin page
		- you can go to the post obj and modify them via the browser (in admin)
		- i.e. change content, author, etc.

tree .                                                                                            
.
├── README.md
├── ira_django_project
│   ├── blog
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-37.pyc
│   │   │   ├── admin.cpython-37.pyc
│   │   │   ├── apps.cpython-37.pyc
│   │   │   ├── models.cpython-37.pyc
│   │   │   ├── urls.cpython-37.pyc
│   │   │   └── views.cpython-37.pyc
│   │   ├── admin.py
│   │   ├── apps.py
│   │   ├── migrations
│   │   │   ├── 0001_initial.py
│   │   │   ├── __init__.py
│   │   │   └── __pycache__
│   │   │       ├── 0001_initial.cpython-37.pyc
│   │   │       └── __init__.cpython-37.pyc
│   │   ├── models.py
│   │   ├── static
│   │   │   └── blog
│   │   │       └── main.css
│   │   ├── templates
│   │   │   └── blog
│   │   │       ├── about.html
│   │   │       ├── base.html
│   │   │       └── home.html
│   │   ├── tests.py
│   │   ├── urls.py
│   │   └── views.py
│   ├── db.sqlite3
│   ├── ira_django_project
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-37.pyc
│   │   │   ├── settings.cpython-37.pyc
│   │   │   ├── urls.cpython-37.pyc
│   │   │   └── wsgi.cpython-37.pyc
│   │   ├── asgi.py
│   │   ├── settings.py
│   │   ├── urls.py
│   │   └── wsgi.py
│   └── manage.py
└── notes.txt
		




>>> TUTORIAL 6 <<<
https://www.youtube.com/watch?v=q4jPR-M0TAQ

- let's make a user registration page
	- user can create an account on website
	- log in and log out via window
		- not enough to use admin window all the time

- user account form will have its own templates, etc.
	- create a new app inside of our project for user login
	- we can update user-like setting in the user app

- python manage.py startapp users
	- create users page where users can create accounts via the frontend 
	- we must first add our new app in our INSTALLED_APPS list in our settings.py file
		- "users.apps.UsersConfig"

- now let's modify the users/views.py file
	- make func register that takes in request
	- django takes care of a lot of user input validation for us
		- don't reinvent the wheel
	- use the user creation form already in Django
		from django.contrib.auth.forms import UserCreationForm
	- creat instance of form in func register
		form = UserCreationForm()
	- return render of this instance with key that will be picked up by users/register.html
		return render(request, 'users/register.html', {'form': form})

- then make a templates/ dir in users/
	- now make another subdir called users/ in templates/
	- make register.html in this subdir
	- make page similar to our about.html child page (i.e. django templating)
		- extend blog/base.html
	- create a new div tag in block content
		- input form with method POST
		- we must add a csrf token -- hidden tag
			- cross site request forgery token -- protection i.e. security
			- must add to every form
			{% csrf_token %}
		- now within here add a fieldset tag with bootstrap class
			- within here, add legend with bootstrap class
	- create another div tag for button
		- use bootstrap class
	- add another div under form for login, do you already have an account button
		- add link to sign in page using the anchor tag (<a>)
			- label it Sign In

- now let's create a url pattern that users can use to navigate to this page
	- go into ira_django_project/urls.py
	from users import views as user_views
	- in index 1 of urlpatterns, add
		path('register/', user_views.register, name='register')

- use as_p to render our content in paragraph form
	- go to register.html
	- fix {{ form }} to {{ form.as_p }}		

- we must register any POST request (i.e. new user) to the db
	- we must parse the post information
	- write the logic under register func in views.py
	- so if we get a post request, make teh UserCreationFrom take in request.Post
		- else take in no param
	def register(request):
    		if request.method == 'POST':
        		form = UserCreationForm(request.POST)
    		else:
        		form = UserCreationForm()
    		return render(request, 'users/register.html', {'form': form})
	- we have to validate our form data
		- do this under request.method conditional
			if form.is_valid():  # i.e. if submitted
				username = form.cleaned_data.get('username')  # username is default by django
		
	- we should have flash message to show we have received the data
		- will only display once, disappear after
		from django.contrib import messages
		- different types of messages
			messages.debug
			messages.info
			messages.success
			messages.warning
			messages.error
		- add this after our username var assignment
			messages.success(request, f"Account created for {username}!")
		
	
	- now we want to navigate folks away from the registration page
		- redirect to the homepage
		- import redirect from django.shortcuts
		- add in if form.is_valid()
			return redirect('blog-home')

	- before we do this, we must complete the addition of our flash message to our base.html
		- we add here because this page is displayed in every page
		- add this right above our {% block content %}:
		{% if messages %}
			{% for message in messages %}
				// input message here...
			{% endfor %}
		{% endif %}
		- add div with bootstrap class 
		<div class="alert alert-{{ message.tags }}">
			{{ message }}
		</div>

	- make sure your password is a valid password specified by django
		- if not, validation errors will be thrown on the form
	- let's get the user created if the form is valid
		if form.is_valid():
			form.save()  # easy!
	- now, create new user in register page and check if it's present in the admin page under User
		- and it is

- let's create an email field for the new user registration form
	- we must add an email field to the form var itself
	- we need a new form that inherits from django's form
		- users/forms.py
	- add this to our new forms
	from django import forms
	from django.contrib.auth.models import User
	from django.contrib.auth.forms  import UserCreationForm
	- create class that inherits UserCreationForm
		- within this class create a class named Meta
		- specify the model Meta should interact with (model = User)
			- now create fields that will show on our form (in order)
			fields = ['username', 'email', 'password1', 'password2']  # password1 is init password, password2 is confirmation
		- class Meta
			- gives us nested namespace for configurations
			- keeps this configuration in one place
	
	- go to views.py and inherit the new class we made
		from .forms import UserRegisterForm
		- change UserCreationForm() to our new class UserRegistrationForm()
		- delete:
		from django.contrib.auth.forms import UserCreationForm
	- now our new register form should be in place
		- test by creating account and verifying in /admin

- let's work on styling for our register page
	- match bootstrap of our home page
	- add appropriate error messages

	- don't work on styling in our forms.py page, but in our templates
	- let's work with crispy forms
	pip install django-crispy-forms

	- add 'crispy_forms' after index 1 of our INSTALLED_APPS list in settings.py
	- add CRISPY_TEMPLATE_PACK = 'bootstrap4' at the bottom of our settings.py
		- reconfigure crispy to take in bootstrap4 (default is bootstrap2)

	- open register.html
		- add {% load crispy_forms_tags %} to line 2
		- remove {% form.as_p %} to {% form|crispy %} -- crispy will take care of this (pipe in crispy attributes)
	
	- the application should now have better error handling feedback due to the crispy bootstrap

tree .                                                                                            
.
├── README.md
├── ira_django_project
│   ├── blog
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-37.pyc
│   │   │   ├── admin.cpython-37.pyc
│   │   │   ├── apps.cpython-37.pyc
│   │   │   ├── models.cpython-37.pyc
│   │   │   ├── urls.cpython-37.pyc
│   │   │   └── views.cpython-37.pyc
│   │   ├── admin.py
│   │   ├── apps.py
│   │   ├── migrations
│   │   │   ├── 0001_initial.py
│   │   │   ├── __init__.py
│   │   │   └── __pycache__
│   │   │       ├── 0001_initial.cpython-37.pyc
│   │   │       └── __init__.cpython-37.pyc
│   │   ├── models.py
│   │   ├── static
│   │   │   └── blog
│   │   │       └── main.css
│   │   ├── templates
│   │   │   └── blog
│   │   │       ├── about.html
│   │   │       ├── base.html
│   │   │       └── home.html
│   │   ├── tests.py
│   │   ├── urls.py
│   │   └── views.py
│   ├── db.sqlite3
│   ├── ira_django_project
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-37.pyc
│   │   │   ├── settings.cpython-37.pyc
│   │   │   ├── urls.cpython-37.pyc
│   │   │   └── wsgi.cpython-37.pyc
│   │   ├── asgi.py
│   │   ├── settings.py
│   │   ├── urls.py
│   │   └── wsgi.py
│   ├── manage.py
│   └── users
│       ├── __init__.py
│       ├── __pycache__
│       │   ├── __init__.cpython-37.pyc
│       │   ├── admin.cpython-37.pyc
│       │   ├── apps.cpython-37.pyc
│       │   ├── forms.cpython-37.pyc
│       │   ├── models.cpython-37.pyc
│       │   └── views.cpython-37.pyc
│       ├── admin.py
│       ├── apps.py
│       ├── forms.py
│       ├── migrations
│       │   ├── __init__.py
│       │   └── __pycache__
│       │       └── __init__.cpython-37.pyc
│       ├── models.py
│       ├── templates
│       │   └── users
│       │       └── register.html
│       ├── tests.py
│       └── views.py
└── notes.txt





>>> TUTORIAL 7 <<<
https://www.youtube.com/watch?v=3aVqWaLjqS4

- create log in and log out capabilities with log-in privileges for the user
- login is taken care of by django (mostly)
	- import login logout views within our projects urls.py
	from django.contrib.auth import views as auth_views  # lot of views import - make new alias for name
	...  # within urlpatterns
	path('login/', auth_views.LoginView.as_view, name='login'),
    	path('logout/', auth_views.LogoutView.as_view, name='logout')

	- what we did here is called class-based views
	- builtin views for login and logout will handle the forms and logic for us
		- templates will not be handled
	- put our login html page in the user/template dir
		- must tell django we want this instead - pass template_name kwarg in as_view method
		path('login/', auth_views.LoginView.as_view(template_name='users/login.html'), name='login'),
		path('logout/', auth_views.LogoutView.as_view(template_name='users/logout.html'), name='logout')
	- build the login.html template
		- make this similar to the register.html template
	- now with href under 'Need An Account?', use {% url 'register' %} to extract the url reference to the registration page
		- fix this for register.html as well ('Already have an account?') --> {% url 'login' %}

	- currently we get a 404 error if we try to log in. it tries to pull up a url page that doesn't have a view attached to it.
		- accounts/profile/
		- django defaults login to go to the account profile page, which may be something we don't want
			- rather redirect to the home page.
		- go to project settings.py and at the very bottom write:
		LOGIN_REDIRECT_URL = 'blog-home'

			- this should allow us to redirect to the home page
			- we should be able to log in now...
			- we can tell this because we have admin privileges
			- test this by logging out of admin and trying to access admin again
				- reconfirm by logging in the user frontent and accessing admin - it should work
		
- let's allow users to access the login page after they register for an account
	- chage success message in users/views.py and the redirect url
	- go to projects urls.py and look at logout
		- if we leave as_view without any args, when we log out our view looks just like when we log out of /admin
		- the page gives us a login page - this is the admin login page, which is not what we want
	- we need to create a logout template in our users template dir

	- create users/logout.html and paste register.html content inside
		- we will not need any forms
		- get rid of crispy forms, <form> ... </form> content, and div class="content-section"
		- only keep the div class="border-top pt-3" to have the login redirect
		- add h2 header and adjust labeling of login link
		- get rid of class="ml-2" because we no longer have text to the left
	- this page should now work
	- the logout functionality should be reflected when you try to log into the admin page
	
- now, let's adjust the navigation bar on the home page so those who are logged in can have a different nav bar than those who are logged out.
	- those who aren't logged in should see the login button on the nav bar
	- those who are logged in should see the logout button on the nav bar

	- let's open up the base template (contains nav) and put conditional to check for login state
		- let's fix the url nav link for login and register 
			e.g. "#" --> "{% url login %}"
		- django has a feature that allows us to look at the current user during a session
			- has attr is_authenticated that allows us if they are currently logged in
		- let's put in this conditional above our nav hyperlinks (login and register)

	- this simple fix should reflect our dynamic nav bar on our home page dependent on our login state

- putting restrictions on certain routes - i.e. you can only go to those routes if you are currently logged in
	- e.g. if i want to edit my profile on twitter without being logged in, they will redirect you to the login page first

	- let's create a route to the user's profile
	- add this to users/views.py
	def profile(request):
	    return render(request, 'users/profile.html')  # simple for now
	- make users/profile.html and copy content from login.html
		- delete everything in the block content template
		- for now have an h1 tag that reflects the username
			{{ user.username }}  # django method
	- now put this redirect into our ira_django_project/urls.py urlpatterns list
	path('profile/', user_views.profile, name='profile')

	- let's also add this page to the nav bar if the user is logged in
		- i.e. the is_authenticated conditonal, place this:
		<a class="nav-item nav-link" href="{% url 'profile' %}">Profile</a>
	- the redirect should now work just fine
		- however, if we log out, we can still access the profile route by typing into the url
		- though no account is listed, this accessibility should be restricted

	- the user should be logged in to access this route
		- this is easy to do - use the django provided login-required decorator
		- add this to users/views.py profile func
		from django.contrib.auth.decorators import login_required
		@login_required  # above profile func
			- note, if we are using class-based views, the login_required is a little bit different
			- we haven't covered this just yet...

		- we should now get a 404 error if we try to access the profile route when logged out
			- we need to django where it can find our login route if this scenario occurs
		- add this to the settings.py at the bottom
		LOGIN_URL = 'login'
			- 'login' is the url pattern we gave to our login route
		- this should work now, but look at the url of our login page we accessed:
		http://localhost:8000/login/?next=/profile/
			- django is keeping track of where to go after we log in (?next=/profile/)
			- we will go to profile page after we log in - django took care of this for us

		- now, the profile page is a page only accessible by people who have logged in
		- if they haven't logged in prior to accessing the profile page, django will ask the user to log in

tree .                                                                                            
.
├── blog
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── apps.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── 0001_initial.py
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       ├── 0001_initial.cpython-37.pyc
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       └── home.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
└── users
    ├── __init__.py
    ├── __pycache__
    │   ├── __init__.cpython-37.pyc
    │   ├── admin.cpython-37.pyc
    │   ├── apps.cpython-37.pyc
    │   ├── forms.cpython-37.pyc
    │   ├── models.cpython-37.pyc
    │   └── views.cpython-37.pyc
    ├── admin.py
    ├── apps.py
    ├── forms.py
    ├── migrations
    │   ├── 0001_initial.py
    │   ├── __init__.py
    │   └── __pycache__
    │       ├── 0001_initial.cpython-37.pyc
    │       └── __init__.cpython-37.pyc
    ├── models.py
    ├── templates
    │   └── users
    │       ├── login.html
    │       ├── logout.html
    │       ├── profile.html
    │       └── register.html
    ├── tests.py
    └── views.py





>>> TUTORIAL 7 <<<
https://www.youtube.com/watch?v=FdVuKt_iuSI

- now we want to make the profile dynamic (i.e. add a profile pic)
- we need to add a field for profile pic
	- extend field for user model
	- create model of profile/user with 1to1 rel
		- i.e. user linked to one profile, profile linked to one user

- need a new model for our profile
	- go to users/models.py
	- extend existing user model
	from django.contrib.auth.models import User

	class Profile(models.Model):
	    user = models.OneToOneField(User, on_delete=models.CASCADE)
	- the models.CASCADE means if the user is deleted, also delete the profile
		- if we delete the profile, we won't delete the user
	
	- let's add a profile picture - right below our user dec
	image = models.ImageField(default='default.jpg', upload_to='profile_pics')
		- default photo if none is selected
		- 'profile_pics' is the dir which pics are stored
	
	- now make a __str__ method to display what we want to see if print is called
	def __str__(self):
	        return f"{self.user.username} Profile"	
	
- any time we make changes to our model, it makes changes to our db
	- this hasn't occurred yet
		- we must make migrations
		python manage.py makemigrations
			- throws an error that says Pillow is not installed
			- a library for working with image in python
		pip install pillow
		- now a new migration file is ready for us (0001_initial.py)
		- migrate this new file
		python manage.py migrate

		- this should work
		- we need to register this model with the admin file of our app (users/admin.py)
		from .models import Profile
		admin.site.register(Profile)

- now let's try to add a profile picture
	- log in and go to admin page
	- there should be a profile section in the admin table
		- currently 0 profiles
		- click add profile and add an image for a user
	- for testing, add a new profile for a user and don't add an image
		- check what the default image is
	
	- run the django shell to look at these profiles
	>>> from django.contrib.auth.models import User
	>>> user = User.objects.filter(username='irahorecka').first()
	>>> user.profile
	<Profile: irahorecka Profile>
	>>> user.profile.image
	<ImageFieldFile: profile_pics/me_arrow.jpeg>
	>>> user.profile.image.width
	1920
	>>> user.profile.image.height
	1050

	- for html, we pass the image location to the source attr of an image tag to display in browser
		- we can use the url attr to find the location
	>>> user.profile.image.url
	'profile_pics/me_arrow.jpeg'
	
	- if another image of the same name was generated, what would happen?
		- a hash value would be added to the end of the image name - no override

	- now let's look at NewUser with the default image
	>>> user = User.objects.filter(username='NewUser').first()
	>>> user
	<User: NewUser>
	>>> user.profile.image
	<ImageFieldFile: default.jpg>

- notice the new dir profile_pics in the ira_django_project dir
	- we need to change some settings to change where these images will be saved
		- also modify how the website will fetch these images
	- add these to settings.py
	MEDIA_ROOT = ''  # full path to where django can find uploaded files
	MEDIA_URL = ''  # how we access these images in the browser

	- convert these to:
	MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
		- os.path.join will create a viable directory no matter what OS you are on
		- BASE_DIR is a dir django created for your base directory
	MEDIA_URL = '/media/'
	
	- we must remove the two profiles we made and create them again (these changes will not be reflected)
		- reload admin page and delete profiles
		- do the same thing and make new profiles
	
	- notice theres a ira_django_project/media/ dir
		- in here, theres the profile_pics dir
	- delete ira_django_projects/profile_pics dir since we won't use this anymore
	
- let's display this in our UI profile page
	- go to users/templates/users/profile.html
		- currently only username is displayed
		- add photo properties
	- add profile.html snippets from his snippets directory
		- make image, email, and username dynamic in the html template

	- now we need to redirect this to our media dir
		- pull up django docs to manage static files
		- what we are doing here should be done only in development
	- we want to modify the urls.py file like this
	from django.conf import settings
	from django.conf.urls.static import static

	# add this to the url_patterns list
	if settings.DEBUG:  # check if we are in a developer environment, i.e. in debug mode
		urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

	- now we should be able to see our profile image and user email in the profile page

- let's add a default image to our profile for users without image in profile
	- currently, django is looking for this image in /media/default.jpg
	- add a default.jpg to the media dir
- NOTE: you must have a profile built for the new user, this is done via the admin page at the moment
	- this should be done on the front end for the user to handle
	- this means that every new user should automatically get a default.jpg profile pic

- give django signal to new user to give this default image
	- make signals.py in users dir
		- some put these signals in models.py, but docs recommend this way to avoid import clashes
	- let's get this written
	from django.db.models.signals import post_save
		- this gets fired after an object gets saved
		- let's get the post_save signal when the user is saved
	from django.contrib.auth.models import User
	- we need to get the receiver (func) to collect this signal and perform some task
	from django.dispatch import receiver
	- finally, import the Profile class from models.py
	from .models import Profile
	
	def create_profile(sender, instance, created, **kwargs):
   		if created:
		Profile.objects.create(user=instance)

	- we want to run this every time a user is created
		- we want to use the receiver we imported
		- use this as a decorator with parameters
	@receiver(post_save, sender=User)

	- SUMMARY: if the user was created, create the profile object with the user = the instance of the user created

	- let's create a save profile every time the user instance is modified
	@receiver(post_save, sender=User)
	def save_profile(sender, instance, **kwargs):
		instance.profile.save()

	- now, we have to import our signals inside our ready func of our users/apps.py file
	- write this as a method in UserConfig class in apps.py
	def ready(self):
	        import users.signals

	- NOW, we should be able to see a default image for our new user (if we register a new user via the front end)
		- this means django created a new profile for us using the signals we set up earlier

tree .                                                                                
.
├── blog
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── apps.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── 0001_initial.py
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       ├── 0001_initial.cpython-37.pyc
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       └── home.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
├── media
│   ├── default.jpg
│   └── profile_pics
│       └── me_arrow.jpeg
└── users
    ├── __init__.py
    ├── __pycache__
    │   ├── __init__.cpython-37.pyc
    │   ├── admin.cpython-37.pyc
    │   ├── apps.cpython-37.pyc
    │   ├── forms.cpython-37.pyc
    │   ├── models.cpython-37.pyc
    │   ├── signals.cpython-37.pyc
    │   └── views.cpython-37.pyc
    ├── admin.py
    ├── apps.py
    ├── forms.py
    ├── migrations
    │   ├── 0001_initial.py
    │   ├── __init__.py
    │   └── __pycache__
    │       ├── 0001_initial.cpython-37.pyc
    │       └── __init__.cpython-37.pyc
    ├── models.py
    ├── signals.py
    ├── templates
    │   └── users
    │       ├── login.html
    │       ├── logout.html
    │       ├── profile.html
    │       └── register.html
    ├── tests.py
    └── views.py





>>> Tutorial 9 <<<
https://www.youtube.com/watch?v=CQ90L5jfldw&list=PL-osiE80TeTtoQCKZ03TU5fNfx2UY6U4p&index=9

- updating our user and profile
	- we need to create some forms, similar to the user register form
	- open up users/forms.py file

- we will create a model form
	- allows us to create a form that will work with a specific db model
	- a form that update our user model (what we want)
	- we want to create a new class (similar to our user register form) (don't include password)
	class UserUpdateForm(forms.ModelForm):
		email = forms.EmailField()

		class Meta:
        		model = User
        		fields = ['username', 'email']  # only want to work with usrename and email

	- later on we will enabel user password change - but not here
	- notice there is no profile pic modification capabilities; this will be in our profile model, not user model
	- we must import our Profile class to work with it i.e. change the image
	class ProfileUpdateForm(forms.ModelForm):
		class Meta:
        		model = Profile
        		fields = ['image']

	- use the UserUpdateForm to update user info, ProfileUpdateForm to update (in our case) the image
	- this will look like just one form on the template

- now let's modify users/views.py
	- import the user and profile form just created:
	from .forms import UserRegisterForm, UserUpdateForm, ProfileUpdateForm

	- then modify the profile func like this:
	@login_required
	def profile(request):
	    u_form = UserUpdateForm()
	    p_form = ProfileUpdateForm()

	    context = {
        	'u_form': u_form,
	        'p_form': p_form
	    }
    
	    return render(request, 'users/profile.html', context)

	- let's modify the profile.html template
		- copy the form tags from register.html and paste into profile.html
		- we are using crispy form tags, make sure you are importing them at the top of the html file
	
	- for our profile template, we will have two profiles with different fields
		- but keep this in one html page (profile.html) (change crispy form load to our new keys)
		{{ u_form|crispy }}
                {{ p_form|crispy }}
	- change legend title and submit button to an appropriate name
	- make sure to add a specific encoding type to our form
		- allows forms to pass image data for our profile pic properly
		- write this as our form tag to allow this feature
		<form method="POST" enctype="multipart/form-data">
			- we need to save the image in the background

	- our profile page (with the cool editing features) should boot up just fine now
		- note: we want to have current username, email, etc. filled in as default for the input boxes
		- also, we want to process the form information when we submit it
			- currently, we post this info back to the forms.py file
	
- filling in default values for boxes in user modification (profile) page
	- go to views.py file in users
	- populate these regular forms with the info of current users
	- pass in instance of the object that it expects (the user)
		- UserUpdateForm -- user obj
		- ProfileUpdateForm -- profile obj

	- go to our profile func and pass these instances in like this
	u_form = UserUpdateForm(instance=request.user)  # user info, like email, username, etc
	p_form = ProfileUpdateForm(instance=request.user.profile)  # profile info, like image

	- put a POST conditional in the profile func (similar to our register func)
	    if request.method == 'POST':
	        u_form = UserUpdateForm(instance=request.user)
        	p_form = ProfileUpdateForm(instance=request.user.profile)
	    else:
        	u_form = UserUpdateForm(instance=request.user)
	        p_form = ProfileUpdateForm(instance=request.user.profile)

	- so if we get a post, we must pass post data
	- with the profile form, we will be getting some additional data (file data with the request) -- image upload
	if request.method == 'POST':
	        u_form = UserUpdateForm(request.POST, instance=request.user)
        	p_form = ProfileUpdateForm(request.POST, request.FILES, instance=request.user.profile)
	    else:
        	u_form = UserUpdateForm(instance=request.user)
	        p_form = ProfileUpdateForm(instance=request.user.profile)

	- now we must make sure that the data coming in are both valid, if not don't save any data
		- similar to user register form
	- if they are both valid, save both forms
	    if request.method == 'POST':
        	u_form = UserUpdateForm(request.POST, instance=request.user)
	        p_form = ProfileUpdateForm(request.POST, request.FILES, instance=request.user.profile)
	        if u_form.is_valid() and p_form.is_valid():
	            u_form.save()
	            p_form.save()
	    else:
	        u_form = UserUpdateForm(instance=request.user)
        	p_form = ProfileUpdateForm(instance=request.user.profile)

	- if it works, tell the user the update was successful and redirect them back to the profile page
		- add a success message and redirect, like this:
		if request.method == 'POST':
	        u_form = UserUpdateForm(request.POST, instance=request.user)
        	p_form = ProfileUpdateForm(request.POST, request.FILES, instance=request.user.profile)
	        if u_form.is_valid() and p_form.is_valid():
        	    u_form.save()
	            p_form.save()
        	    messages.success(request, "Your accound has been updated!.")
	            return redirect('profile')  # name for url pattern to login page

	- we want to return redirect within this conditional here (instead of down at the bottom of func) because:
		- this is called the post get redirect pattern
		- this is when you reload the page and it says are you sure you want to confirm resubmission?
			- your browser is telling you you will run another post request when you reload the page
		- this early return will cause the browser to get a GET request rather than POST

	- NOW the update you make in the profile route looks good
	- go to admin to make sure this is executed properly
		- both user and profile features look good

- now we want to automatically resize images when we upload them
	- CSS set to 125px for largest image
		- no use in having a large 4000px image
		- takes up a lot of space in the file system
		- slows down your browser due to it having to send a large file image every time it is requested

	- use pillow to resize these image -- backend image handler
	- we need to override the save method of our profile model
	- go to users/models.py
	- add this to our Profile class
	from PIL import Image
	def save(self):
        	# method that is run after our model is saved -- override default save method
	        super().save()  # run the save method of our parent save method (call super)

        	img = Image.open(self.image.path)

	- we initially want to save the image using the parent save method
	- then, let's open the image using PIL.Image
	- now it's time to resize this
		- so we have 125px in the main CSS, so let's resize somewhere close to that (300px for now)
		- if img is larger than this, images will be sized down
		if img.height > 300 or img.width > 300:
           	    output_size = (300, 300)
	            img.thumbnail(output_size)        
        	    img.save(self.image.path)

		- what we did here is resize the image if its init height and width > 300
		- THEN, we save the new image, overriding our previous save

	- there may be other ways to resize images, perhaps you may want to look into this if you are working with larger projects
	- NOW, if we update or create a new profile with an image, it should be 300x300 if the init image was any larger in any dimension

- let's display the image of the user beside their post
	- go to our blog/templates/home.html
	- add this segment of html code between our article and div tags
	<img class="rounded-circle article-img" src="{{ post.author.profile.image.url }}>"
		- use the bootstrap rounded-circle css class with tutor's article-img css class

	- NOW, the user profile pic should be alongside their post in the home page

tree .                                                                                           
.
├── blog
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── apps.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── 0001_initial.py
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       ├── 0001_initial.cpython-37.pyc
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       └── home.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
├── media
│   ├── default.jpg
│   └── profile_pics
│       ├── Hank_Williams.jpeg
│       ├── me_arrow.jpeg
│       ├── me_arrow_sWiq1Sv.jpeg
│       ├── vaporwave_1.jpeg
│       ├── vaporwave_1_fb8s8bI.jpeg
│       └── vaporwave_1_g16IaWF.jpeg
└── users
    ├── __init__.py
    ├── __pycache__
    │   ├── __init__.cpython-37.pyc
    │   ├── admin.cpython-37.pyc
    │   ├── apps.cpython-37.pyc
    │   ├── forms.cpython-37.pyc
    │   ├── models.cpython-37.pyc
    │   ├── signals.cpython-37.pyc
    │   └── views.cpython-37.pyc
    ├── admin.py
    ├── apps.py
    ├── forms.py
    ├── migrations
    │   ├── 0001_initial.py
    │   ├── __init__.py
    │   └── __pycache__
    │       ├── 0001_initial.cpython-37.pyc
    │       └── __init__.cpython-37.pyc
    ├── models.py
    ├── signals.py
    ├── templates
    │   └── users
    │       ├── login.html
    │       ├── logout.html
    │       ├── profile.html
    │       └── register.html
    ├── tests.py
    └── views.py





>>> TUTORIAL 10 <<<
https://www.youtube.com/watch?v=-s7e_Fy6NRU

- goal:
	- give users the ability to make posts that will appear on the home page
	- use class-based views to work with our post models

- using class-based views
	- go to blog/views.py
	- currently we are using a function-based approach for handling the html views content
	
	- class-based views have built in functionality that'll handle a lot of backend things
		- different kinds
			- list
			- detail
			- create
			- update
			- delete
		- a blog page might use the list based view (blogs appear in a list)
		- youtube will list a subscriptions page -- i.e. a list based view
			- if we click on a list view here, we'd be taken to a detail view
		- have the ability to update and delete our videos
			- update view
			- delete view

	- django tries to predict some of this behavior
	- let's try to manipulate the home page views

	- modify the following:
		from django.views.generic import ListView
		# create class that inherits ListView - must create var called model
		# what model to query to create the list -- i.e. all of the posts
		class PostListView(ListView):
    			# we need to create a var called model
			model = Post

	- now let's modify our blogs/urls.py to handle our new class-based views
	from django.urls import path
	from .views import PostListView
	from . import views

	urlpatterns = [
	    #  pass in PostListView.as_view() argument -- .as_view() allows us to get the view obj
	    path('', PostListView.as_view(), name='blog-home'),
	    path('about/', views.about, name='blog-about'),
	]
	
		- we get a TemplateDoesNotExist error if we just pass this in
		- class based views look for templates with a certain pattern
			- blog/post_list.html
			- i.e. <app>/<model>_<viewtype>.html
		- we can change the template this page is looking for
		- add this to our PostListView class
		template_name = 'blog/home.html'  # <app>/<model>_<viewtype>.html

		- we need to create a content our html can loop over (i.e. context)
		- add this to below template_name (set an attribute)
		context_object_name = 'posts'  # i.e. posts == context key in our home func

		- NOW our page should load just fine

- we must change the ordering of our posts -- currently new posts are at the bottom
	- let's see the latest ones at the top
	- change our query order to the db
	add this var to our PostListView class to order by date_posted
	ordering = ['-date_posted']  # goes oldest to newest -- add a '-' in front to reverse this order

	- in our func view (home) we had to render the func and explicitly pass in var info
	- if we stick to our conventions in our class based view, we can execute a good render with one line of code

	- let's create a view for individual post (detail view)
	- in our blog/views.py, create a new class for detailed view
	class PostListView(DetailView):
	    model = Post

	- now, let's create a route in our urls.py
	from .views import PostListView, PostDetailView

	- we must create a url pattern that contains a variable
		- i.e. an id of a post is part of the route
	- add this within our urlpatterns
	path('post/<int:pk>/', PostDetailView.as_view(), name='post-detail'),  # pk = primary key, int is the type
	
	- the <int:pk> will allow us to grab that key value from our url and use it in our view func
		- NOTE: our detail views expect a default 'pk' var -- can be modified if desired
	
	- create a template that will display our detail views
		- because we want to stick to convention, let's create the default html file via the route: <app>/<model>_<viewtype>.html
		- create blog/templates/blog/post_detail.html
		- very similar to home.html -- copy it over
			- remove looping over template sector -- we're looking at only one post
			- remove post.title as a link, therefore remove the anchor tag in line 10
				- keep post.title for the header
		- when dealing with detailed views, it expects the context of the template to be called 'object' (i.e. change 'post')
			- change all the post var to say object
			- i.e post.content --> object.content

		- NOW, we can visit http://localhost:8000/post/1/ and see post 1 on a single page

- let's add links to these individual post routes on our home page (i.e. title of our blog)
	- these can be found in our home template
	- look at line 11 of home.html in our post.title anchor tag (notice the #)
	- swap the # for {% url 'post-detail' post.id%}
	
	- NOW, we should be able to click on our post title and go to our individual post (detail view)
	
	- if we route to a post id that doesn't exist, we would get a 404 error (e.g. post/10/)

- let's make a create, update, and delete view so we can do all of these with post on the front end
	- how do we create a new post
	- go to blog/views.py
	import CreateView
	class PostCreateView(CreateView):
	    model = Post

	- now, we must pass in arguments we want to be in the created post (pass this in our class)
		- e.g. title and content (date posted will be created automatically)
	- add this to our class:
	fields = ['title', 'content']

	- go to blog/urls.py and import PostCreateView and add this to urlpatterns:
	path('post/new/', PostCreateView.as_view(), name='post-create'),

	- we need to create a template for this form -- now, the default name is not as expected (post_create)
		- the default is <model>_form.html
	- the html layout is really similar to our register template - let's copy that over
		- keep 'form' in the django template -- django expects that to be our template name as default (for create view)
	- we need to change the legend and submit
		- legend: Blog Post
		- submid: Post
		- we can delete the div with Already have an account?

	- NOW, we should be able to go to http://localhost:8000/post/new/ and see the form to create a new blog post

	- why class based views are powerful:
		- we didn't have to create a forms module to create this form
		- all we did is tell the create view to work with the post model and add the title and content field within that form
	
	- BUT if we try to create a new post, this won't work (an IntegrityError will be thrown)
		- we need an author id
			- i.e. current logged in user

- we must override the form valid method for our create view -- add this method in our PostCreateView class
	def form_valid(self, form):
	        # set author of form before submission
        	form.instance.author = self.request.user
	        # validate form by running the form_valid method on our parent class
        	return super().form_valid(form)

	- now let's try to run this...
	- we get an ImproperlyConfigured error
		- we don't have a redirect url
	- NOTICE, if we go back to home, our blog post was created just fine
	- let's redirect to the detailed page afterwards
		- we must create a get absolute url method in our model
	
	- open up blog/models.py
		- we need to get the url of a particular route
			- we need to use the reverse func (not redirect)
			- redirect = redirect to specific route
			- reverse = return the full url to that route as a str
	
	- django will autocomplete most of this for you (standard method), but add this to our Post class (method)
	def get_absolute_url(self):
	        return reverse("post_detail", kwargs={"pk": self.pk})

	- if we want to go to the home page after submission, we can set an attr in the create view called success_url and set to home page
	- this would've take a lot more code if we did this with regular functions instead

- we need to make it that we can only create posts if we are logged in as the user
	- if we try to access this without logging in --> go to log in page
		- we saw how to do this using the func method (using decorators)
	- we need to use a login mixin
		- class we inherit from which will add this functionality

	- go to blog/views.py
	from django.contrib.auth.mixins import LoginRequiredMixin
	- modify args in class PostCreateView like so:
	class PostCreateView(LoginRequiredMixin, CreateView):

	- NOW, we should be redirected to the login page if we try to create a post without logging in

- let's create an update feature on the front end to update blog posts
	- go to blog/views.py
	import UpdateView
	class PostUpdateView(LoginRequiredMixin, UpdateView):
	    model = Post
	    fields = ['title', 'content']
	    # override the form valid method
    
	    def form_valid(self, form):
        	# set author of form before submission
	        form.instance.author = self.request.user
        	# validate form by running the form_valid method on our parent class
	        return super().form_valid(form)
	
	- now go to urls.py and add
	import PostUpdateView
	- add this to the urlpatterns list
	path('post/<int:pk>/update', PostUpdateView.as_view(), name='post-update'),
		- since we are providing the primary key, django updateview will take care of everything else
		- it will use the same post_form template for the create view

	- NOW, if we go to a blog post and go to update (e.g. localhost:8000/post/5/update), we should be able to update it and redirect ourself back to the details page

- always plan for people using and abusing your application
	- for example, we aren't checking if the correct author is trying to update his/her post -- could they update another post?
	- right now, we can update someone else's blog post -- not good
	
	- we'll need another mixin
	- go to blog/views.py
	from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
	
	- add this method to our PostUpdateView class
	def test_func(self):
	        """UserPassesTestMixin will run this to check for correct
	        conditions, i.e. correct author"""
	        post = self.get_object()  # get post we are currently trying to update
        	# check current user is author of post
	        if self.request.user == post.author:
        	    return True
	        return False

	- NOW, if we try to edit someone else's post, we will get a 403 Forbidden error.

- let's create a delete view for deleting posts
	- let's go to blog/views.py
	import DeleteView
	- two requirements for access
		- user is logged in
		- user is the author to delete
	- we'll copy the inherited mixins from PostUpdateView
	- we'll also copy the test_func method from the PostUpdateView

	- let's go to blog/urls.py
	import PostDeleteView 
	- now we need to add a path to our urlpatterns
	path('post/<int:pk>/delete', PostDeleteView.as_view(), name='post-delete'),

	- now, lets create the form for this route
		- what this form will do is ask if we are sure we want to delete this post
		- this post will be calles post_confirm_delete.html

	- go to blog/templates
		- create post_confirm_delete.html
		- copy content from post_form.html
	- change certain features
		- legend: make to Delete Post
		- doesn't pass form, so remove crispy forms 
			- rm django template
			- rm form django template
	- just a page that asks if we want to delete the post
		- if submit, delete post
	- add h2 tag under legend asking for confirmation
	<h2>Are you sure you want to delete the post " {{ object.title }}</h2>
	- change submit button to Yes, Delete
		- give class of btn btn-outline-danger

	- add cancel link that'll take them back to post detail view
		- if they changed their mind
		- add this as an anchor tag
		<a class="btn btn-outline-secondary" href="{% url 'post-detail' object.id %}">Cancel</a> <!-- use btn btn-outline-secondary for muted style -->

	- NOW, we should be able to access the delete view of our website (e.g. http://localhost:8000/post/8/delete)
	- however, if we delete the post, we get an ImporperlyConfigured error
		- we need to have a redirect url upon deletion -- need to provide a success url
		- post hasn't been deleted due to the exception
	- go to blog/views.py
		- add this to PostDeleteView
		success_url = '/'
			- redirect user back to home page after 'successful' deletion
	
	- NOW, we should be able to delete and go back to the home page

- we added all of this functionality using class based views

- let's add links to access these functionalities on the front end
	- let's put a new link in our navigation bar to create a new post
		- open blog/templates/base.html
		- go to the <!-- Navbar Right Side -->
		- add this under div class navbar-nav
		<a class="nav-item nav-link" href="{% url 'post-create' %}">New Post</a>

	- let's add links to update and delete posts
		- go to post details page
		- i.e. post_detail.html
		- add this to line 9 (under small tag)
		{% if object.author == user %}
        	        <a class="btn btn-secondary btn-sm mt-1 mb-1" href="{% url 'post-update' object.id %}">Update</a>
	                <!-- btn-secondary = muted button, btn-sm = small button, mt-1 = margin top 1, mb-1 = margin bottom 1-->
                	<a class="btn btn-danger btn-sm mt-1 mb-1" href="{% url 'post-delete' object.id %}">Delete</a>
	                <!-- btn-danger = danger button -->
            	{% endif %}

	- let's make the update and delete button on a new line
		- open post_detail.html again	
		- wrap the code above in a div tag, indent as needed

tree .                                                                                            
.
├── blog
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── apps.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── 0001_initial.py
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       ├── 0001_initial.cpython-37.pyc
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       ├── home.html
│   │       ├── post_confirm_delete.html
│   │       ├── post_detail.html
│   │       └── post_form.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
├── media
│   ├── default.jpg
│   └── profile_pics
│       ├── Hank_Williams.jpeg
│       ├── Screen_Shot_2019-08-04_at_5.47.57_PM.png
│       ├── me_arrow.jpeg
│       ├── me_arrow_sWiq1Sv.jpeg
│       ├── vaporwave_1.jpeg
│       ├── vaporwave_1_fb8s8bI.jpeg
│       └── vaporwave_1_g16IaWF.jpeg
└── users
    ├── __init__.py
    ├── __pycache__
    │   ├── __init__.cpython-37.pyc
    │   ├── admin.cpython-37.pyc
    │   ├── apps.cpython-37.pyc
    │   ├── forms.cpython-37.pyc
    │   ├── models.cpython-37.pyc
    │   ├── signals.cpython-37.pyc
    │   └── views.cpython-37.pyc
    ├── admin.py
    ├── apps.py
    ├── forms.py
    ├── migrations
    │   ├── 0001_initial.py
    │   ├── __init__.py
    │   └── __pycache__
    │       ├── 0001_initial.cpython-37.pyc
    │       └── __init__.cpython-37.pyc
    ├── models.py
    ├── signals.py
    ├── templates
    │   └── users
    │       ├── login.html
    │       ├── logout.html
    │       ├── profile.html
    │       └── register.html
    ├── tests.py
    └── views.py





>>> TUTORIAL 11 <<<
https://www.youtube.com/watch?v=acOktTcTVEQ

- we will add pagination so we don't pull down too many posts at once
- we can create a page of posts by a user that will also be paginated

- let's get some json files to work with pagination
	- go to snippets code and copy over
	- label it 'posts.json' and put the file in the main projects folder
	- NOTE: the posts are currently on one line - that's ok for the json file to compile

- to add the json file to our application, open up python manage.py shell and write the following:
>>> import json
>>> from blog.models import Post
>>> with open('posts.json') as f:
...     posts_json = json.load(f)
...
>>> for post in posts_json:
...     post = Post(title=post['title'], content=post['content'], author_id=post['user_id'])
...	post.save()

- NOTE: I deleted users as I went along this project -- user_id 2 no longer exists, only 1 (irahorecka) and 6 (NewUser4)
	- change all instances of "user_id": 2 to "user_id": 6 in json file.
	- now we can create posts in the iterator
	- note, the keys we are accessing are the keys used in the json file (e.g. ['content'])

- Lorem ipsum is considered a filler text universally, where meaning of the text does not matter, but rather the styling of text on a page.

- if we run our server, all of our posts should be on a single page
	- if we actually had this (with images included), loading at once a massive page like this will take a lot of resource
- we'll be working with a paginator object
	- open our shell (django) and type this
	>>> from django.core.paginator import Paginator
	>>> posts = ['1', '2', '3', '4', '5']
	>>> p = Paginator(posts, 2)  # the second argument 2 means we want two posts per page
		- i.e. 3 pages total
	>>> p.num_pages
	3
	- loop over every page in the Paginator obj
	>>> for page in p.page_range:
	...     print(page)
	...
	1
	2
	3
	- if we want to access a page, we would:
	>>> p1 = p.page(1)
	>>>
	>>> p1
	<Page 1 of 3>
	>>> p1.number
	1
	- now if we want to view the content (obj) of page 1 (p1) we would:
	>>> p1.object_list
	['1', '2']
	
	- most important feature we'll be creating is checking whether there are previous/next pages
		- in our example, we should not have a previous page
		>>> p1.has_previous()
		False
		>>> p1.has_next()
		True
		>>> p1.next_page_number()
		2

- let's paginate our posts
	- open blog/views.py
	- go to PostListView (so many posts here)
	- add this attr to the class
	paginate_by = 2  # no. posts per page

	- NOW, there should be only 2 blog posts per page
	- manually type localhost:/8000/?page=2 to view page 2 of our blog lists
		- if we try to access a page that doesn't exist, i.e. 18, we will get a 404 error

- let's add links to view first, previous, successive, and last posts (in the template)
	- go to blog/templates/blog/home.html
	- our class based view already passes in the context we'll need to access this page information
	
	- open a new line under {% endfor %}

	{% if is_paginated %}

        {% if page_obj.has_previous %}  <!-- page object our view passed into our template -->
            <a class="btn btn-outline-info mb-4" href="?page=1">First</a>  <!-- route to first page - link -->
            <a class="btn btn-outline-info mb-4" href="?page={{ page_obj.previous_page_number }}">Previous</a>  <!-- route to previous page - link -->
        {% endif %}

        <!-- add features that will allow nearby next and prev pages to also show up -->
        {% for num in page_obj.paginator.page_range %}
            {% if page_obj.number == num %}  <!-- check if the page number is current page -->
                <a class="btn btn-info mb-4" href="?page={{ num }}">{{ num }}</a>
            {% elif num > page_obj.number|add:'-3' and num < page_obj.number|add:'3' %}  <!-- if the number we're on is within 3 previous and forward pages -->
                <a class="btn btn-outline-info mb-4" href="?page={{ num }}">{{ num }}</a>
            {% endif %}
        {% endfor %}

        <!-- if next page exists, allow user to jump to next pages and the last page -->
        {% if page_obj.has_next %}  <!-- page object our view passed into our template -->
            <a class="btn btn-outline-info mb-4" href="?page={{ page_obj.next_page_number }}">Next</a>  <!-- route to next page - link -->
            <a class="btn btn-outline-info mb-4" href="?page={{ page_obj.paginator.num_pages }}">Last</a>  <!-- route to last page number -->
        {% endif %}

    	{% endif %}

	- NOW, we should be able to see first, previous, previous current successive pages, next, and last page buttons with appropriate functionality
	- Pagination is now done

- let's change our posts per page to a higher value
	- let's try 5
	- go to blog/views.py
	change paginate_by to 5
	- NOW, there should be 5 blog items per page

 
- let's make the user link (i.e. in the home page) active and route them to the user page with his/her blog posts
	- go to blog/views.py and write the following:
	from django.shortcuts import render, get_object_or_404
	from django.contrib.auth.models import User  # must import user obj

	- make a new list view class
	class UserPostListView(ListView):
	    model = Post
	    template_name = 'blog/user_posts.html'  # <app>/<model>_<viewtype>.html
	    context_object_name = 'posts'
	    # ordering = ['-date_posted']
	    paginate_by = 5

	    def get_query_set(self):
 	       """get the user associated with the username (get from url)
        	if user does not exist, return 404 page does not exist"""
	        user = get_object_or_404(User, username=self.kwargs.get('username'))  # get username from the parameter in the url
        	# we are overriding the query the list view is making, we are overriding ['-date_posted'] above -- move below like so
	        return Post.objects.filter(author=user).order_by('-date_posted')  # limit posts on page to this filter

	- let's create this path in our urlpatterns
	- open blog/urls.py and add:
	from .views import UserPostListView
	- add this to urlpatterns:
	path('user/<str:username>', UserPostListView.as_view(), name='user-post'),  # username with string dtype and name it 'user-post'

	- now we must create a template called user_posts.html (assigned in UserPostListView)
	- make this html file in blog/templates/blog
	- this will be very similar to our home page content (home.html), and keep the pagination when you copy it over
		- user post pages can be paginated if they have enough posts
	- add heading under the {% block content %} block:
	<h1 class="mb-3">Posts by {{ view.kwargs.username }} ({{ page_obj.paginator.count }})</h1>  <!-- get username passed into our url with total posts the author made -->

	- modify line 9 of user_posts.html like so:
	<a class="mr-2" href="{% url 'user-post' post.author.username %}">{{ post.author }}</a>  <!-- take url pattern from url-post and get author username -->

	- we need to add links to our user route to our home page and post detail template
		- we are repeating code here, but we will fix this in later tutorials
	- copy the href code block snippet above
	- post this block in the href of line 8 of our home.html page

	- go to post_detail.html
	- copy the href above in line 7 to our dead href link
		- change the post.author.username to object.author.username due to the following code block calling object.author
	<a class="mr-2" href="{% url 'user-post' object.author.username %}">{{ object.author }}</a>  <!-- get user's url route -->
	
	- NOW, our username link on the homepage should be active
		- HOWEVER, when we click on this link, we see posts from every user on the blog -- this is wrong

- let's fix the query set of user page fetch
	- go to blog/views.py
	- under UserPostListView:
		def get_query_set(self) --> def get_queryset(self)  # a built in django method
	
	- NOW, everything should work -- appropriate user and their post count + content when clicking on their username link in the home page blog

	- make sure we get a 404 error if we navigate to a username that doesn't exist
		- e.g. localhost:8000/user/BadUser
		- and indeed, we get a 404 error

tree .                                                                                            
.
├── blog
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── apps.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── 0001_initial.py
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       ├── 0001_initial.cpython-37.pyc
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       ├── home.html
│   │       ├── post_confirm_delete.html
│   │       ├── post_detail.html
│   │       ├── post_form.html
│   │       └── user_posts.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
├── media
│   ├── default.jpg
│   └── profile_pics
│       ├── Hank_Williams.jpeg
│       ├── Screen_Shot_2019-08-04_at_5.47.57_PM.png
│       ├── me_arrow.jpeg
│       ├── me_arrow_sWiq1Sv.jpeg
│       ├── vaporwave_1.jpeg
│       ├── vaporwave_1_fb8s8bI.jpeg
│       └── vaporwave_1_g16IaWF.jpeg
├── posts.json
└── users
    ├── __init__.py
    ├── __pycache__
    │   ├── __init__.cpython-37.pyc
    │   ├── admin.cpython-37.pyc
    │   ├── apps.cpython-37.pyc
    │   ├── forms.cpython-37.pyc
    │   ├── models.cpython-37.pyc
    │   ├── signals.cpython-37.pyc
    │   └── views.cpython-37.pyc
    ├── admin.py
    ├── apps.py
    ├── forms.py
    ├── migrations
    │   ├── 0001_initial.py
    │   ├── __init__.py
    │   └── __pycache__
    │       ├── 0001_initial.cpython-37.pyc
    │       └── __init__.cpython-37.pyc
    ├── models.py
    ├── signals.py
    ├── templates
    │   └── users
    │       ├── login.html
    │       ├── logout.html
    │       ├── profile.html
    │       └── register.html
    ├── tests.py
    └── views.py





>>> Tutorial 12 <<<
https://www.youtube.com/watch?v=-tyBEsHSv7w

- learn how to use email users to reset passwords
	- django has functionality to generate token to send to user who wants a password reset

- go into ira_django_project/urls.py 
	- create paths with the built in views in urlpatterns
	- create url pattern called password reset ('password-reset/')
	path('password-reset/',
         auth_views.PasswordResetView.as_view(
         template_name='users/password_reset.html'),
         name='password_reset'),  # asks user if password reset necessary

	- this will send password reset form to user to fill out (password reset instruction to their email)

- let's create the password_reset.html template in users/templates/users
	- have password_reset.html present a form for filling out the email address
	- copy template from login.html
	- change line 8: Reset Password
	- change line 12: Request Password
	- delete div underneath <form> (i.e. remove 'Need An Account?'

- we need to create a page for after this form is submitted successfully
	- route that confirms email has been set + suggests that you check your inbox
	- let's create this

	- go to urlpatterns in ira_django_project/urls.py
	- copy the password reset item in list
		- paste below with modifications:
		path('password-reset/done/',
	         auth_views.PasswordResetDoneView.as_view(
        	 template_name='users/password_reset_done.html'),
	         name='password_reset_done'),  # page to confirm email has been sent

- we need to create a template for password_reset_done view
	- go to users/templates/users and create password_reset_done.html
		- this will be an informative page -- i.e. no forms
	- copy the logout.html template
	- modify the html doc as follows:
		- remove everything inside the content block
		- put a bootstrap alert on this page in the div tag (within content block)
	<div class="alert alert-info">
        	An email has been sent with instructions to reset your password.
	</div>

	- open this in browser to see if this is working:
		- as expected, we get an exception: NoReverseMatch at /password-reset/
		- it's looking for a password_reset_confirm route
		- the error occurred at {{ protocol }}://{{ domain }}{% url 'password_reset_confirm' uidb64=uid token=token %}
			- trying to create a url to this password_reset_confirm route
			- the template that threw this error is called 'password_reset_email.html'
		- it is trying to pass two things to the url parameter
			- uidb64
				- users id encoded in base64
			- token
				- token to check the password is valid
		- we need to accept these tokens in our url so we know the person who requested the password reset is the person trying to access that page
			- adds a layer of security

- let's create the password reset route the password_reset.html is routing us to
	- open up ira_django_project/urls.py and go to urlpatterns
	- create a route for password_reset_confirm in urlpatterns
	path('password-reset-confirm/<uidb64>/<token>/',  # must accept uidb64 and token parameters (expected)
         auth_views.PasswordResetConfirmView.as_view(
         template_name='users/password_reset_confirm.html'),
         name='password_reset_confirm'),  # page to confirm password reset
	
	- now go to users/templates/users and create password_reset_confirm.html
		- this will have a form for us to reset our password
		- let's copy the password_reset.html over
		- change Request Password Reset to Reset Password (line 12)

	- now, let's try to resubmit our password reset form on the browser (i.e. pass in your email)
		- now we're getting a new exception: ConnectionRefusedError at /password-reset/
		- this error is less helpful than most other pages
			- tries to send an email or failing
			- we don't have an email server to send an email

	- several choices we can make to send email
		- in this video, we will be using gmail
		- using gmail is a better example of how things will likely be done in production
	
	- to do this with gmail, we might have to let google know to expect sign-in from a python application
		- enable two factor authentication
		- create password specifically for the app we want to sign in from
			- https://accounts.google.com/signin/v2/sl/pwd?service=accountsettings&passive=1209600&osid=1&continue=https%3A%2F%2Fmyaccount.google.com%2Fapppasswords&followup=https%3A%2F%2Fmyaccount.google.com%2Fapppasswords&rart=ANgoxccGd5zEAsFFYBYKpRkOS8tXlM37FWA-aVGXFjfwXO5APe-3f_vrGlZJbP4_zQI_iiXFK9V4tGp9QUzark1ej2kiYsJPNg&authuser=0&csig=AF-SEnaSmjWXBfGS7saH%3A1587776287&flowName=GlifWebSignIn&flowEntry=ServiceLogin
		- follow these instructions to allow python to use our gmail account

	- open ira_django_project/settings.py
		- scroll to the bottom so set a few more variables
		EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
		EMAIL_HOST = 'smtp.gmail.com'
		EMAIL_PORT = 587
		EMAIL_USE_TLS = True

	- ** WATCH how to hide sensitive passwords in your environment variable **
		https://www.youtube.com/watch?reload=9&v=5iWhQWVXosU
		- go to /Users/irahorecka/Desktop/Harddrive_Desktop/CS/CoreySchafer to view notes
	
	- add these variables to our ira_django_project/settings.py at the bottom:
		EMAIL_HOST_USER = os.environ.get('EMAIL_USER')
		EMAIL_HOST_PASSWORD = os.environ.get('EMAIL_PASS')
		- make sure to set these variables in ~/.bash_profile appropriately (set to our gmail account)

	- NOW, we should theoretically be able to send our user a password reset email through the django frontend
		- make sure you configures ~/.bash_profile correctly with your username and password
		- make sure you enable third party use of your gmail account on google apps
		- the email says, "password reset on localhost:8000"
	- nocite the reset email url that is sent
	http://localhost:8000/password-reset-confirm/MQ/5fy-a329d646e16fe4dfee82/
		- you have the uidb64 key (MQ)
		- you have the token 5fy-a329d646e16fe4dfee82
	- click on the password reset link that was sent

	- if we set a new password and click submit, we get an exception: NoReverseMatch at /password-reset-confirm/MQ/set-password/
		- we need a route called password-reset-complete

	- open ira_django_project/urls.py and go to urlspattern
	- add:
	path('password-reset-complete/',
         auth_views.PasswordResetCompleteView.as_view(
         template_name='users/password_reset_complete.html'),
         name='password_reset_complete'),  # route after successful password change
	- now, go to users/templates/users and create password_reset_complete.html
	- an informative template (no forms) -- similar to password_reset_done.html
		- keep the alert class
		- set alert title to Your password has been set.
		- link them to the sign-in page with an anchor tag:
		<a href="{% url 'login' %}">Sign In Here</a>

	- NOW, the navigation to the login page should be complete

- let's make a link for a password reset
	- we should have this option on the login page
	- go to users/templates/users and open login.html
	- put the reset password link right after the submit button
	<small class="test-muted ml-2">
        	<a href="{% url 'password-reset' %}">Forgot Password?</a>
        </small>	
		- i.e. after the submit button

	- if we load the password reset link, we get an exception: NoReverseMatch at /login/
		- change 'password-reset' to 'password_reset' in our login.html

	- NOW, we can see the Forgot Password? link and it routes us to the reset password form

- leave the password token and handling to django for now!

tree .                                                                    
.
├── blog
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── apps.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── 0001_initial.py
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       ├── 0001_initial.cpython-37.pyc
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       ├── home.html
│   │       ├── post_confirm_delete.html
│   │       ├── post_detail.html
│   │       ├── post_form.html
│   │       └── user_posts.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── ira_django_project
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
├── media
│   ├── default.jpg
│   └── profile_pics
│       ├── Hank_Williams.jpeg
│       ├── IMG_1959.jpg
│       ├── Screen_Shot_2019-08-04_at_5.47.57_PM.png
│       ├── me_arrow.jpeg
│       ├── me_arrow_sWiq1Sv.jpeg
│       ├── vaporwave_1.jpeg
│       ├── vaporwave_1_fb8s8bI.jpeg
│       └── vaporwave_1_g16IaWF.jpeg
├── posts.json
└── users
    ├── __init__.py
    ├── __pycache__
    │   ├── __init__.cpython-37.pyc
    │   ├── admin.cpython-37.pyc
    │   ├── apps.cpython-37.pyc
    │   ├── forms.cpython-37.pyc
    │   ├── models.cpython-37.pyc
    │   ├── signals.cpython-37.pyc
    │   └── views.cpython-37.pyc
    ├── admin.py
    ├── apps.py
    ├── forms.py
    ├── migrations
    │   ├── 0001_initial.py
    │   ├── __init__.py
    │   └── __pycache__
    │       ├── 0001_initial.cpython-37.pyc
    │       └── __init__.cpython-37.pyc
    ├── models.py
    ├── signals.py
    ├── templates
    │   └── users
    │       ├── login.html
    │       ├── logout.html
    │       ├── password_reset.html
    │       ├── password_reset_complete.html
    │       ├── password_reset_confirm.html
    │       ├── password_reset_done.html
    │       ├── profile.html
    │       └── register.html
    ├── tests.py
    └── views.py


	
	
	

	

	
	
























